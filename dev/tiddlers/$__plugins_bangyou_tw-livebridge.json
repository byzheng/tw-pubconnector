{"tiddlers": {
"$:/plugins/bangyou/tw-livebridge/icon/vscode": {
    "title": "$:/plugins/bangyou/tw-livebridge/icon/vscode",
    "author": "konpa",
    "created": "20250812035339520",
    "modified": "20250812053107358",
    "source": "https://svgicons.com/icon/26983/vscode",
    "source-author": "konpa",
    "source-icon-set": "Devicon Plain",
    "source-license": "mit",
    "source-url": "https://svgicons.com/icon/26983/vscode",
    "tags": "",
    "type": "text/vnd.tiddlywiki",
    "text": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 128 128\"><path fill=\"currentColor\" fill-rule=\"evenodd\" d=\"M90.767 127.126a7.97 7.97 0 0 0 6.35-.244l26.353-12.681a8 8 0 0 0 4.53-7.209V21.009a8 8 0 0 0-4.53-7.21L97.117 1.12a7.97 7.97 0 0 0-9.093 1.548l-50.45 46.026L15.6 32.013a5.33 5.33 0 0 0-6.807.302l-7.048 6.411a5.335 5.335 0 0 0-.006 7.888L20.796 64L1.74 81.387a5.336 5.336 0 0 0 .006 7.887l7.048 6.411a5.33 5.33 0 0 0 6.807.303l21.974-16.68l50.45 46.025a8 8 0 0 0 2.743 1.793Zm5.252-92.183L57.74 64l38.28 29.058V34.943Z\" clip-rule=\"evenodd\"/></svg>",
    "revision": "0",
    "bag": "default"
},

"$:/plugins/bangyou/tw-livebridge/license": {
    "title": "$:/plugins/bangyou/tw-livebridge/license",
    "created": "20221022071850561",
    "modified": "20250808103735012",
    "tags": "",
    "type": "text/vnd.tiddlywiki",
    "text": "Distributed under an MIT license.\n\n<<<\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n<<<",
    "revision": "0",
    "bag": "default"
},

"$:/plugins/bangyou/tw-livebridge/readme": {
    "title": "$:/plugins/bangyou/tw-livebridge/readme",
    "created": "20240802085639320",
    "modified": "20250923003413784",
    "tags": "",
    "type": "text/vnd.tiddlywiki",
    "text": "; tw-livebridge\n\nTW LiveBridge creates a real-time WebSocket link between TiddlyWiki and external tools like VS Code and R, enabling instant two-way communication. Edit a tiddler in your editor and preview it live in the browser, or click in TiddlyWiki to open the tiddler in your editorâ€”no manual refresh required.\n\n; Used in other tools\n\nThe bidirectional communication features of TW LiveBridge are leveraged by other projects to enhance their workflows:\n\n* [[TiddlyEdit|https://github.com/byzheng/vscode-tiddlyedit/]] (VS Code extension) â€“ allows seamless editing of tiddlers directly from VS Code.\n* [[rtiddlywiki|https://github.com/byzheng/rtiddlywiki/]] (R package) â€“ enables preview of R Markdown files inside TiddlyWiki.\n\nThese tools donâ€™t use the plugin code directly; instead, they rely on the real-time communication channel established by TW LiveBridge.\n\n;Code and demo\n\nFor learning plugin features, syntax, tutorial and examples see the plugin demo and code pages\n\n* Demo: https://tw-livebridge.bangyou.me\n* Code: https://github.com/byzheng/tw-livebridge\n",
    "revision": "0",
    "bag": "default"
},

"$:/plugins/bangyou/tw-livebridge/styles/doclink.css": {
    "title": "$:/plugins/bangyou/tw-livebridge/styles/doclink.css",
    "text": ".tw-doclink {\r\n    color: #9e83ca;              /* Indigo-700 */\r\n    text-decoration: none;\r\n    font-weight: 500;\r\n    border-bottom: 1px dotted currentColor;\r\n    cursor: pointer;\r\n    transition: color 0.15s ease, border-bottom-style 0.15s ease;\r\n    position: relative;\r\n}\r\n\r\n/* Book icon prefix */\r\n.tw-doclink::before {\r\n    content: \"ðŸ“„\";\r\n    font-size: 0.85em;\r\n    margin-right: 0.25em;\r\n    opacity: 0.75;\r\n    vertical-align: baseline;\r\n}\r\n\r\n/* Hover */\r\n.tw-doclink:hover {\r\n    color: #5b21b6;              /* Indigo-800 */\r\n    border-bottom-style: solid;\r\n}\r\n\r\n/* Active / click */\r\n.tw-doclink:active {\r\n    color: #4c1d95;              /* Indigo-900 */\r\n}\r\n",
    "created": "20260112002633093",
    "modified": "20260112002641685",
    "tags": "$:/tags/Stylesheet",
    "type": "text/css",
    "revision": "0",
    "bag": "default"
},

"$:/plugins/bangyou/tw-livebridge/ui/ViewToolBar/EditInVSCode": {
    "title": "$:/plugins/bangyou/tw-livebridge/ui/ViewToolBar/EditInVSCode",
    "created": "20220819054026245",
    "creator": "Bangyou Zheng",
    "description": "Open in Visual Studio Code",
    "modified": "20250812113854144",
    "modifier": "Bangyou Zheng",
    "tags": "$:/tags/ViewToolbar",
    "type": "text/vnd.tiddlywiki",
    "text": "\\define open-in-vscode()\n<$button tooltip=\"Open in VS Code\" class={{$:/config/Toolbar/ButtonClass}}>\n    {{$:/plugins/bangyou/tw-livebridge/icon/vscode}}\n    <$action-sendmessage\n        $message=\"tm-open-in-vscode\"\n        $param=<<currentTiddler>> />\n</$button>\n\\end\n\n<<open-in-vscode>>\n",
    "revision": "0",
    "bag": "default"
},

"$:/plugins/bangyou/tw-livebridge/widget/opendoc.js": {
    "title": "$:/plugins/bangyou/tw-livebridge/widget/opendoc.js",
    "text": "\r\n/*\\\r\ntitle: $:/plugins/bangyou/tw-livebridge/widget/opendoc.js\r\ntype: application/javascript\r\nmodule-type: widget\r\nopendoc for TiddlyWiki\r\n\r\n\\*/\r\n\r\n\r\n'use strict';\r\n\r\n(function () {\r\n\r\n    /*jslint node: true, browser: true */\r\n    /*global $tw: false */\r\n    \"use strict\";\r\n    //const fs = require('fs');\r\n    var Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\r\n\r\n    var OpenDocWidget = function (parseTreeNode, options) {\r\n        this.initialise(parseTreeNode, options);\r\n    };\r\n\r\n    /*\r\n    Inherit from the base widget class\r\n    */\r\n    OpenDocWidget.prototype = new Widget();\r\n\r\n\r\n    /*\r\n    Render this widget into the DOM\r\n    */\r\n    OpenDocWidget.prototype.render = function (parent, nextSibling) {\r\n        var self = this;\r\n        this.parentDomNode = parent;\r\n        this.computeAttributes();\r\n\r\n        // Get attributes\r\n        var page = this.getAttribute(\"page\") || \"\";\r\n        var title = this.getAttribute(\"title\") || page;\r\n\r\n        // Create link element\r\n        var linkDom = document.createElement('a');\r\n        linkDom.href = \"#\";\r\n        linkDom.textContent = title;\r\n        linkDom.className = \"tw-doclink\";\r\n\r\n        // Add click handler\r\n        linkDom.addEventListener('click', function(event) {\r\n            event.preventDefault();\r\n            $tw.rootWidget.dispatchEvent({\r\n                type: \"tm-open-doc\",\r\n                param: page,\r\n                paramObject: {page: page}\r\n            });\r\n        });\r\n\r\n        parent.insertBefore(linkDom, nextSibling);\r\n        this.domNodes.push(linkDom);\r\n    };\r\n\r\n    OpenDocWidget.prototype.refresh = function (changedTiddlers) {\r\n        return false;\r\n    };\r\n\r\n    exports[\"open-doc\"] = OpenDocWidget;\r\n})();\r\n",
    "type": "application/javascript",
    "module-type": "widget",
    "created": "20260111235249201",
    "modified": "20260112001029861",
    "revision": "0",
    "bag": "default"
},

"$:/plugins/bangyou/tw-livebridge/ws/browser.js": {
    "title": "$:/plugins/bangyou/tw-livebridge/ws/browser.js",
    "text": "/*\\\r\ntitle: $:/plugins/bangyou/tw-livebridge/ws/browser.js\r\ntype: application/javascript\r\nmodule-type: startup\r\n\\*/\r\n(function () {\r\n    \"use strict\";\r\n\r\n    exports.name = \"ws-client\";\r\n    exports.platforms = [\"browser\"];\r\n    exports.after = [\"startup\"];\r\n    exports.synchronous = true;\r\n\r\n    exports.startup = function () {\r\n\r\n        async function isNodeServerWiki() {\r\n            try {\r\n                const response = await fetch(\"/status\", { method: \"GET\" });\r\n                if (response.ok) {\r\n                    const data = await response.json();\r\n                    return !!data.space; // or check for other server-only properties\r\n                }\r\n                return false;\r\n            } catch (err) {\r\n                return false;\r\n            }\r\n        }\r\n        if (!$tw.browser) {\r\n            console.warn(\"WS client disabled: not running in browser\");\r\n            return;\r\n        }\r\n        const loc = window.location;\r\n        if (loc.protocol === \"file:\") {\r\n            console.warn(\"WS client disabled: running from local file\");\r\n            return;\r\n        }\r\n\r\n        // Validate hostname and port\r\n        if (!loc.hostname) {\r\n            console.warn(\"WS client disabled: hostname is empty\");\r\n            return;\r\n        }\r\n        let ws;\r\n        async function initWSClient() {\r\n            const isServer = await isNodeServerWiki();\r\n            if (!isServer) {\r\n                console.log(\"WS Client disabled: not running with Node.js server\");\r\n                return;\r\n            }\r\n            // Use default port 80 if loc.port is empty\r\n            const port = loc.port ? loc.port : (loc.protocol === \"https:\" ? \"443\" : \"80\");\r\n\r\n            const wsUrl = `ws://${loc.hostname}:${port}/ws`;\r\n\r\n            if (ws && ws.readyState === WebSocket.OPEN) {\r\n                return;\r\n            }\r\n\r\n            ws = new WebSocket(wsUrl);\r\n\r\n            ws.addEventListener(\"open\", () => {\r\n                console.log(\"Connected to WS server\");\r\n            });\r\n\r\n            ws.addEventListener(\"message\", (event) => {\r\n                let data;\r\n                try {\r\n                    data = JSON.parse(event.data);\r\n                } catch (e) {\r\n                    console.error(\"Invalid WS data\", event.data);\r\n                    return;\r\n                }\r\n                // console.log(\"WS message in browser:\", data);\r\n\r\n                if (data.type === \"open-tiddler\" && data.title) {\r\n                    openTiddlerInStoryRiver(data.title, data.offset);\r\n                }\r\n            });\r\n\r\n            // Reconnect logic\r\n            let reconnectAttempts = 0;\r\n            const maxReconnectDelay = 30000; // 3 seconds\r\n            const MAX_RECONNECT_ATTEMPTS = 10;\r\n            // Limit reconnect attempts to 10\r\n            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\r\n                console.error(`WS reconnect failed after ${MAX_RECONNECT_ATTEMPTS} attempts. Giving up.`);\r\n                return;\r\n            }\r\n            function reconnectWS() {\r\n                reconnectAttempts++;\r\n                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), maxReconnectDelay);\r\n                console.warn(`WS disconnected. Reconnecting in ${delay / 1000}s...`);\r\n                setTimeout(() => {\r\n                    initWSClient();\r\n                }, delay);\r\n            }\r\n\r\n            ws.addEventListener(\"close\", reconnectWS);\r\n            ws.addEventListener(\"error\", (e) => {\r\n                console.error(\"WS error:\", e);\r\n                ws.close();\r\n            });\r\n            // console.log($tw.rootWidget);\r\n            $tw.rootWidget.addEventListener(\"tm-open-in-vscode\", function (event) {\r\n                const title = event.param;\r\n                if (ws && ws.readyState === WebSocket.OPEN) {\r\n                    ws.send(JSON.stringify({ type: \"edit-tiddler\", title }));\r\n                } else {\r\n                    console.warn(\"WebSocket not connected\");\r\n                }\r\n                return true; // stops bubbling\r\n            });\r\n\r\n            $tw.rootWidget.addEventListener(\"tm-open-doc\", function (event) {\r\n                const page = event.paramObject && event.paramObject.page ? event.paramObject.page : event.param;\r\n                if (ws && ws.readyState === WebSocket.OPEN) {\r\n                    ws.send(JSON.stringify({ type: \"open-doc\", page }));\r\n                } else {\r\n                    console.warn(\"WebSocket not connected\");\r\n                }\r\n                return true; // stops bubbling\r\n            });\r\n        };\r\n\r\n        initWSClient();\r\n\r\n        document.addEventListener('visibilitychange', () => {\r\n            if (document.visibilityState === 'visible') {\r\n                if (!ws || ws.readyState === WebSocket.CLOSED) {\r\n                    console.log(\"Page visible again - attempting WS reconnect\");\r\n                    initWSClient();\r\n                }\r\n            }\r\n        });\r\n\r\n    };\r\n\r\n    // Track the current highlight timeout to prevent overlapping animations\r\n    let highlightTimeout = null;\r\n\r\n    async function openTiddlerInStoryRiver(title, offset) {\r\n        // Force sync from server and wait for completion\r\n        if ($tw.syncer) {\r\n            $tw.syncer.syncFromServer();\r\n            // Additional small delay to ensure rendering is complete\r\n            await new Promise(resolve => setTimeout(resolve, 500));\r\n        }\r\n\r\n        const openLinkFromInsideRiver = $tw.wiki.getTiddler(\"$:/config/Navigation/openLinkFromInsideRiver\").fields.text;\r\n        const openLinkFromOutsideRiver = $tw.wiki.getTiddler(\"$:/config/Navigation/openLinkFromOutsideRiver\").fields.text;\r\n\r\n        const story = new $tw.Story({ wiki: $tw.wiki });\r\n\r\n        if (!$tw.wiki.tiddlerExists(title)) {\r\n            console.warn(\"Tiddler does not exist:\", title);\r\n            return;\r\n        }\r\n\r\n        // Get the currently selected tiddler in the river\r\n        let currentTiddler = null;\r\n        const historyList = $tw.wiki.getTiddler(\"$:/HistoryList\");\r\n        if (historyList && historyList.fields && historyList.fields[\"current-tiddler\"]) {\r\n            currentTiddler = historyList.fields[\"current-tiddler\"];\r\n        }\r\n        \r\n        const tiddlersInStoryRiver = $tw.wiki.getTiddlerList(\"$:/StoryList\");\r\n        // Check if tiddler is already open in the story river or complete out of view\r\n        if (!(tiddlersInStoryRiver.includes(title) && !isTiddlerElementOutView(title))) {\r\n            story.addToStory(title, currentTiddler, {\r\n                openLinkFromInsideRiver,\r\n                openLinkFromOutsideRiver\r\n            });\r\n            story.addToHistory(title);\r\n            \r\n            // Wait for the UI to render the new tiddler\r\n            await new Promise(resolve => setTimeout(resolve, 200));\r\n        }\r\n\r\n        // Scroll to offset if provided (non-blocking)\r\n        if (offset !== undefined && offset >= 0) {\r\n            // Use setTimeout to make scroll non-blocking\r\n            setTimeout(async () => {\r\n                await scrollToElementByOffset(title, offset);\r\n            }, 100);\r\n        }\r\n\r\n    }\r\n\r\n    function isTiddlerElementOutView(title) {\r\n        // Find the tiddler div in the StoryRiver by data-tiddler-title\r\n        const selector = `div[data-tiddler-title=\"${title.replace(/\"/g, '\\\\\"')}\"]`;\r\n        const el = document.querySelector(selector);\r\n\r\n        if (!el) {\r\n            // Not even rendered\r\n            return false;\r\n        }\r\n\r\n        // Check if element is within the viewport\r\n        const rect = el.getBoundingClientRect();\r\n        // Check if any part of the element is in the viewport\r\n        const isCompletelyOutOfViewport = (\r\n            rect.bottom <= 0 ||\r\n            rect.top >= window.innerHeight ||\r\n            rect.right <= 0 ||\r\n            rect.left >= window.innerWidth\r\n        );\r\n\r\n        return isCompletelyOutOfViewport;\r\n    }\r\n\r\n    /**\r\n     * Recursively find the deepest element containing the offset and track the path\r\n     * @param {Object|Array} node - The node or array to search\r\n     * @param {number} offset - The offset in the raw text\r\n     * @param {Array} path - The path of parent elements\r\n     * @returns {Object|null} Object with { element, topLevelParent } or null\r\n     */\r\n    function findDeepestElementWithPath(node, offset, path = []) {\r\n        // If it's an array, search each item\r\n        if (Array.isArray(node)) {\r\n            for (const item of node) {\r\n                const result = findDeepestElementWithPath(item, offset, path);\r\n                if (result) return result;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Must be an object with start and end\r\n        if (!node || typeof node !== 'object' || node.start === undefined || node.end === undefined) {\r\n            return null;\r\n        }\r\n\r\n        // Check if offset is within this element's range\r\n        if (node.start <= offset && offset <= node.end) {\r\n            // Add current node to the path\r\n            const currentPath = [...path, node];\r\n            \r\n            // Check children first to find the deepest match\r\n            if (node.children && Array.isArray(node.children)) {\r\n                const childResult = findDeepestElementWithPath(node.children, offset, currentPath);\r\n                if (childResult) return childResult;\r\n            }\r\n            \r\n            // If no deeper child found, this is the deepest element\r\n            // Return the element and its top-level parent (first in path)\r\n            return {\r\n                element: node,\r\n                topLevelParent: currentPath[0] || node\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find the element in the parsed tree that contains the given offset\r\n     * @param {Array} parsedTree - The parsed tree array from $tw.wiki.parseTiddler().tree\r\n     * @param {number} offset - The offset in the raw text\r\n     * @returns {Object|null} The matching top-level element or null if not found\r\n     */\r\n    function findElementByOffset(parsedTree, offset) {\r\n        if (!parsedTree || !Array.isArray(parsedTree)) {\r\n            return null;\r\n        }\r\n\r\n        // Find the deepest element containing the offset and its top-level parent\r\n        const result = findDeepestElementWithPath(parsedTree, offset);\r\n        \r\n        if (result && result.topLevelParent) {\r\n            return result.topLevelParent;\r\n        }\r\n\r\n        // If no exact match, find the nearest top-level element\r\n        // This handles empty lines that aren't in the parsed tree\r\n        let nearestElement = null;\r\n        let minDistance = Infinity;\r\n\r\n        for (const element of parsedTree) {\r\n            let distance;\r\n            if (offset < element.start) {\r\n                // Offset is before this element\r\n                distance = element.start - offset;\r\n            } else if (offset > element.end) {\r\n                // Offset is after this element\r\n                distance = offset - element.end;\r\n            } else {\r\n                // Should have been caught above, but just in case\r\n                return element;\r\n            }\r\n\r\n            if (distance < minDistance) {\r\n                minDistance = distance;\r\n                nearestElement = element;\r\n            }\r\n        }\r\n\r\n        return nearestElement;\r\n    }\r\n\r\n    /**\r\n     * Get all content elements from the tiddler body that correspond to parsed tree elements\r\n     * @param {Element} bodyElement - The tiddler body DOM element\r\n     * @returns {Array} Array of DOM elements matching parsed tree structure\r\n     */\r\n    function getContentElements(bodyElement) {\r\n        const elements = [];\r\n        \r\n        // Check if this is a section-editor tiddler\r\n        if (bodyElement.querySelector('.se-tc-tiddler-body')) {\r\n            // Section-editor structure\r\n            // Headers: header > button > h*\r\n            const allElements = Array.from(bodyElement.querySelectorAll('header.se-sectionheader > button > h1, header.se-sectionheader > button > h2, header.se-sectionheader > button > h3, header.se-sectionheader > button > h4, header.se-sectionheader > button > h5, header.se-sectionheader > button > h6, div.se-sectionbody > div.se-section-view > p > *'));\r\n            \r\n            // Filter out <p style=\"\">&nbsp;</p> elements\r\n            const filtered = allElements.filter(el => {\r\n                if (el.tagName === 'P' && el.innerHTML.trim() === '&nbsp;') {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            \r\n            elements.push(...filtered);\r\n        } else {\r\n            // Normal tiddler - direct children\r\n            elements.push(...bodyElement.children);\r\n        }\r\n        \r\n        return elements;\r\n    }\r\n\r\n    /**\r\n     * Scroll to the HTML element that corresponds to an offset in the raw text\r\n     * @param {string} title - The tiddler title\r\n     * @param {number} offset - The offset in the raw text\r\n     */\r\n    async function scrollToElementByOffset(title, offset) {\r\n        // Retry logic in case DOM isn't ready yet\r\n        let attempts = 0;\r\n        const maxAttempts = 5;\r\n        \r\n        while (attempts < maxAttempts) {\r\n            // Get the tiddler's parse tree\r\n            const parseResult = $tw.wiki.parseTiddler(title);\r\n            if (!parseResult || !parseResult.tree) {\r\n                console.warn(\"Cannot parse tiddler:\", title);\r\n                return;\r\n            }\r\n\r\n            const parsedTree = parseResult.tree;\r\n\r\n            // Find the element in the parsed tree\r\n            const element = findElementByOffset(parsedTree, offset);\r\n            if (!element) {\r\n                console.warn(\"No element found at offset:\", offset);\r\n                return;\r\n            }\r\n\r\n            // Find the index of this element in the parsed tree\r\n            const elementIndex = parsedTree.indexOf(element);\r\n            if (elementIndex === -1) {\r\n                console.warn(\"Element not found in tree\");\r\n                return;\r\n            }\r\n\r\n            // Find the tiddler container in the DOM\r\n            const tiddlerSelector = `div[data-tiddler-title=\"${title.replace(/\"/g, '\\\\\"')}\"]`;\r\n            const tiddlerContainer = document.querySelector(tiddlerSelector);\r\n\r\n            if (!tiddlerContainer) {\r\n                attempts++;\r\n                if (attempts < maxAttempts) {\r\n                    await new Promise(resolve => setTimeout(resolve, 100));\r\n                    continue;\r\n                }\r\n                console.warn(\"Tiddler element not found after retries:\", title);\r\n                return;\r\n            }\r\n\r\n            // Find the tiddler body element (support both normal and section-editor)\r\n            let bodyElement = tiddlerContainer.querySelector('.tc-tiddler-body.tc-clearfix.tc-reveal');\r\n            if (!bodyElement) {\r\n                bodyElement = tiddlerContainer.querySelector('.se-tc-tiddler-body.tc-reveal');\r\n            }\r\n            \r\n            if (!bodyElement) {\r\n                attempts++;\r\n                if (attempts < maxAttempts) {\r\n                    await new Promise(resolve => setTimeout(resolve, 100));\r\n                    continue;\r\n                }\r\n                console.warn(\"Tiddler body element not found after retries\");\r\n                return;\r\n            }\r\n\r\n            // Get content elements that match the parsed tree structure\r\n            const contentElements = getContentElements(bodyElement);\r\n\r\n            // The element at the same index should correspond to the parsed tree element\r\n            if (elementIndex < contentElements.length) {\r\n                const targetElement = contentElements[elementIndex];\r\n                \r\n                // Scroll the element into view\r\n                targetElement.scrollIntoView({\r\n                    behavior: 'smooth',\r\n                    block: 'center',\r\n                    inline: 'nearest'\r\n                });\r\n\r\n                // Clear any existing highlight timeout\r\n                if (highlightTimeout) {\r\n                    clearTimeout(highlightTimeout);\r\n                    highlightTimeout = null;\r\n                }\r\n\r\n                // Reset any existing highlight before applying new one\r\n                const existingHighlights = document.querySelectorAll('[data-tw-highlight=\"true\"]');\r\n                existingHighlights.forEach(el => {\r\n                    el.style.backgroundColor = '';\r\n                    el.style.transition = '';\r\n                    el.removeAttribute('data-tw-highlight');\r\n                });\r\n\r\n                // Highlight the element temporarily\r\n                targetElement.setAttribute('data-tw-highlight', 'true');\r\n                targetElement.style.transition = 'background-color 0.5s';\r\n                const originalBackground = targetElement.style.backgroundColor;\r\n                targetElement.style.backgroundColor = 'rgba(255, 255, 0, 0.3)';\r\n                \r\n                highlightTimeout = setTimeout(() => {\r\n                    targetElement.style.backgroundColor = originalBackground;\r\n                    setTimeout(() => {\r\n                        targetElement.style.transition = '';\r\n                        targetElement.removeAttribute('data-tw-highlight');\r\n                    }, 500);\r\n                    highlightTimeout = null;\r\n                }, 1000);\r\n                \r\n                return; // Success\r\n            } else {\r\n                attempts++;\r\n                if (attempts < maxAttempts) {\r\n                    await new Promise(resolve => setTimeout(resolve, 100));\r\n                    continue;\r\n                }\r\n                console.warn(\"Element index out of range:\", elementIndex, \"content elements count:\", contentElements.length);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n})();\r\n",
    "type": "application/javascript",
    "module-type": "startup",
    "created": "20250808104706169",
    "modified": "20250808105942897",
    "tags": "",
    "revision": "0",
    "bag": "default"
},

"$:/plugins/bangyou/tw-livebridge/ws/server.js": {
    "title": "$:/plugins/bangyou/tw-livebridge/ws/server.js",
    "text": "/*\\\r\ntitle: $:/plugins/bangyou/tw-livebridge/ws/server.js\r\ntype: application/javascript\r\nmodule-type: startup\r\n\r\n\\*/\r\n(function () {\r\n    \"use strict\";\r\n\r\n    exports.name = \"ws-server\";\r\n    exports.platforms = [\"node\"];\r\n    exports.after = [\"load-modules\"];\r\n    exports.synchronous = true;\r\n\r\n    exports.startup = function () {\r\n console.log(\"Starting ws server\")\r\n        if (!$tw.node) {\r\n            console.warn(\"WS server disabled: not running in Node.js\");\r\n            return;\r\n        }\r\n        $tw.hooks.addHook(\"th-server-command-post-start\", function (simpleServer, httpServer, serverName) {\r\n            const WebSocket = require(\"ws\");\r\n            const wss = new WebSocket.Server({ server: httpServer, path: \"/ws\" });\r\n            console.log(\"WebSocket server running at /ws\");\r\n\r\n            const clients = new Set();\r\n\r\n            wss.on(\"connection\", (ws) => {\r\n                //console.log('Client connected');\r\n                clients.add(ws);\r\n                ws.isAlive = true;\r\n\r\n                ws.on(\"pong\", () => {\r\n                    console.log(\"Received pong from client\");\r\n                    ws.isAlive = true;\r\n                });\r\n\r\n                ws.on(\"message\", (msg) => {\r\n                    let data;\r\n                    if (Buffer.isBuffer(msg)) {\r\n                        msg = msg.toString();\r\n                    }\r\n                    console.log(\"Received:\", msg);\r\n                    try {\r\n                        data = JSON.parse(msg);\r\n                    } catch (e) {\r\n                        console.error(\"Invalid WS message\", msg);\r\n                        return;\r\n                    }\r\n                    \r\n\r\n                    // Relay to all other clients\r\n                    clients.forEach(client => {\r\n                        console.log(\"Relaying to client:\", client.readyState);\r\n                        if (client !== ws && client.readyState === WebSocket.OPEN) {\r\n                            client.send(JSON.stringify(data));\r\n                            //console.log(\"Relayed to client:\", data);\r\n                        }\r\n                    });\r\n\r\n                });\r\n\r\n                ws.on(\"close\", () => {\r\n                    clients.delete(ws);\r\n                });\r\n\r\n                ws.on(\"error\", () => {\r\n                    clients.delete(ws);\r\n                });\r\n            });\r\n            // ðŸ”‘ Heartbeat: ping clients every 30s\r\n            const interval = setInterval(() => {\r\n                clients.forEach((ws) => {\r\n                    if (!ws.isAlive) {\r\n                        clients.delete(ws);\r\n                        return ws.terminate(); // no pong â†’ drop\r\n                    }\r\n                    ws.isAlive = false;\r\n                    console.log(\"Sending ping to client\");\r\n                    ws.ping(); // trigger pong from client\r\n                });\r\n            }, 30000); // 30 seconds\r\n        });\r\n\r\n    };\r\n\r\n})();\r\n\r\n",
    "type": "application/javascript",
    "module-type": "startup",
    "created": "20250808104139856",
    "modified": "20250808105952943",
    "tags": "",
    "revision": "0",
    "bag": "default"
}}
}