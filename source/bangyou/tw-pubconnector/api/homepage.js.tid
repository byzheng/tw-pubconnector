created: 20250614140336200
creator: Bangyou Zheng
modified: 20250614140345878
modifier: Bangyou Zheng
module-type: library
revision: 0
tags: 
title: $:/plugins/bangyou/tw-pubconnector/api/homepage.js
type: application/javascript

/*\
title: $:/plugins/bangyou/tw-pubconnector/api/homepage.js
type: application/javascript
module-type: library

Authoring publication from homepage. Assume all dois in the homepage are published by the author
\*/

(function (exports) {
    'use strict';
    if (!$tw.node) {
        return;
    }
    const fetch = require('node-fetch');

    // use cache

    const helper = require('$:/plugins/bangyou/tw-pubconnector/utils/helper.js').Helper();
    const cacheHelper = require('$:/plugins/bangyou/tw-pubconnector/api/cachehelper.js').cacheHelper("homepage", 9999999);

    const platform_field = "url"; // Field in tiddler that contains the WOS researcher ID

    function Homepage() {

        function isEnabled() {
            let tiddler = $tw.wiki.getTiddler("$:/config/tw-pubconnector/authoring/homepage/enable");
            if (!tiddler) {
                return true; // default to enabled ("yes")
            }
            return tiddler && tiddler.fields.text === "enable";
        }
        async function cacheWorks(url) {
            if (!isEnabled()) {
                return;
            }
            if (!url || typeof url !== "string") {
                throw new Error("Invalid URL provided");
            }
            const cacheResult = cacheHelper.getCacheByKey(url);
            if (cacheResult) {
                return cacheResult.item;
            }
            try {
                const TIMEOUT_MS = 15000; // adjust as needed
                // Use AbortController from global scope (available in Node.js 15+)
                const AbortController = globalThis.AbortController;
                if (!AbortController) {
                    throw new Error('AbortController not available. Please use Node.js 15 or higher.');
                }
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
                try {
                    const response = await fetch(url, { signal: controller.signal });
                    if (!response || !response.ok) {
                        await cacheHelper.addEntry(url, []);
                        return;
                    }
                    const html = await response.text();
                    const dois = helper.extractDOIs(html);
                    await cacheHelper.addEntry(url, dois);
                    return dois;
                } finally {
                    clearTimeout(timeoutId);
                }
            } catch (err) {
                if (err && err.name === 'AbortError') {
                    console.error('Fetch aborted (timeout) for URL:', url);
                } else {
                    console.error('Error processing request:', err && err.message ? err.message : err);
                }
                try {
                    await cacheHelper.addEntry(url, []);
                } catch (cacheErr) {
                    console.error('Failed to write empty cache entry for', url, cacheErr);
                }
            }


        }

        function getAuthorByDOI(doi) {
            if (!isEnabled()) {
                return [];
            }
            if (!doi || doi.length === 0) {
                throw new Error("Invalid DOI provided");
            }
            if (typeof doi !== "string") {
                throw new Error("DOI must be a string");
            }
            const caches = cacheHelper.getCaches();
            if (!caches || caches.length === 0) {
                return [];
            }
            let matchedUrls = [];
            for (const key in caches) {
                if (Object.prototype.hasOwnProperty.call(caches, key)) {
                    const cache = caches[key];
                    if (!Array.isArray(cache.item)) continue;
                    if (cache.item.some(d => typeof d === "string" && d.toLowerCase() === doi.toLowerCase())) {
                        matchedUrls.push(key);
                        break;
                    }
                }
            }
            if (matchedUrls.length === 0) {
                return [];
            }
            let results = [];
            for (matchedUrl in matchedUrls) {
                const filter = `[tag[Colleague]] :filter[get[url]match:caseinsensitive[${matchedUrl}]]`;
                const matchingTiddlers = $tw.wiki.filterTiddlers(filter);
                if (matchingTiddlers.length > 0) {
                    results.push(matchingTiddlers);
                }
            }
            return results;
        }

        function removeExpiredEntries() {
            cacheHelper.removeExpiredEntries();
        }
        return {
            isEnabled: isEnabled,
            cacheWorks: cacheWorks,
            getAuthorByDOI: getAuthorByDOI,
            getPlatformField: function () {
                return platform_field;
            },
            removeExpiredEntries: removeExpiredEntries
        };

    }


    exports.Homepage = Homepage;
})(exports);



